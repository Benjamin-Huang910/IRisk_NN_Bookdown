[["multi-layer-nn-model.html", "Chapter 5 Multi-Layer NN Model 5.1 Generate Data 5.2 Functions 5.3 Test 5.4 Cross Validation 5.5 Next Steps", " Chapter 5 Multi-Layer NN Model This chapter presents the final functional-programming model. Uses functions to define ‘neural networks’, perform forward propagation, and perform gradient descent. Section at the end details future components that could be added in. 5.1 Generate Data For now, having 3 inputs and combining them to create y, with a random error term. Would like to tweak the setup eventually. library(tidyverse) ## Warning: package &#39;tidyverse&#39; was built under R version 4.2.3 ## Warning: package &#39;ggplot2&#39; was built under R version 4.2.3 ## Warning: package &#39;tibble&#39; was built under R version 4.2.3 ## Warning: package &#39;tidyr&#39; was built under R version 4.2.3 ## Warning: package &#39;readr&#39; was built under R version 4.2.3 ## Warning: package &#39;purrr&#39; was built under R version 4.2.3 ## Warning: package &#39;dplyr&#39; was built under R version 4.2.3 ## Warning: package &#39;stringr&#39; was built under R version 4.2.3 ## Warning: package &#39;forcats&#39; was built under R version 4.2.3 ## Warning: package &#39;lubridate&#39; was built under R version 4.2.3 ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.3 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.3 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.2 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors ## create data: m &lt;- 1000 n_1_manual &lt;- 3 n_L_manual &lt;- 1 # initialize Xs X &lt;- data.frame(X1 = runif(n = m, min = -10, max = 10), X2 = rnorm(n = m, mean = 0, sd = 10), X3 = rexp(n = m, rate = 1)) %&gt;% as.matrix(nrow = m, ncol = n_1_manual) # get response Y &lt;- X[, 1] + 10 * sin(X[, 2])^2 + 10 * X[, 3] + rnorm(n = 1000) # fix dims according to NN specs X &lt;- t(X) Y &lt;- t(Y) # Create line chart for each variable par(mfrow = c(1, 3)) # Set up plotting layout for (i in 1:3) { plot(X[i, ], type = &quot;l&quot;, main = paste(&quot;Line Chart for&quot;, rownames(X)[i]), xlab = &quot;Observation&quot;, ylab = &quot;Value&quot;) } # Create histogram for each variable par(mfrow = c(1, 3)) # Reset plotting layout for (i in 1:3) { hist(X[i, ], main = paste(&quot;Histogram for&quot;, rownames(X)[i]), xlab = &quot;Value&quot;, ylab = &quot;Frequency&quot;, col = &quot;skyblue&quot;, border = &quot;black&quot;) } # Create histogram for Y variable hist(Y, main = &quot;Histogram for Y&quot;, xlab = &quot;Value&quot;, ylab = &quot;Frequency&quot;, col = &quot;skyblue&quot;, border = &quot;black&quot;) # Select a subset of Y values to display on the dot chart subset_Y &lt;- Y[seq(1, length(Y), by = 10)] # Adjust the &#39;by&#39; value as needed to control the density # Create dot chart for Y variable with subset of values dotchart(subset_Y, main = &quot;Dot Chart for Y&quot;, xlab = &quot;Value&quot;, ylab = &quot;Observation&quot;) 5.2 Functions 5.2.1 Link Functions ## Specify Link Functions &amp; Derivatives get_link &lt;- function(type = &quot;sigmoid&quot;) { if (type == &quot;identity&quot;) { # identity g &lt;- function(x) {x} } else if (type == &quot;sigmoid&quot;) { # sigmoid g &lt;- function(x) {1 / (1 + exp(-x))} } else if (type == &quot;softmax&quot;) { # softmax g &lt;- function(x) { exp_x &lt;- exp(x - max(x)) # Subtracting max(x) for numerical stability return(exp_x / sum(exp_x)) } } else if (type == &quot;relu&quot;) { # ReLU g &lt;- function(x) {x * as.numeric(x &gt; 0)} } else (return(NULL)) return(g) } get_link_prime &lt;- function(type = &quot;sigmoid&quot;) { if (type == &quot;identity&quot;) { # identity [FIX] g_prime &lt;- function(x) {rep(1, length(x))} } else if (type == &quot;sigmoid&quot;) { # sigmoid g_prime &lt;- function(x) {exp(-x) / (1 + exp(-x))^2} } else if (type == &quot;softmax&quot;) { # Derivative of softmax g_prime &lt;- function(x) { s &lt;- get_link(&quot;softmax&quot;)(x) return(s * (1 - s)) } } else if (type == &quot;relu&quot;) { # ReLU g_prime &lt;- function(x) {as.numeric(x &gt; 0)} } else (return(NULL)) return(g_prime) } 5.2.2 Loss Functions ## Specify Loss Functions &amp; Derivatives get_loss_function &lt;- function(type = &quot;squared_error&quot;) { if (type == &quot;squared_error&quot;) { loss &lt;- function(y_hat, y) {sum((y_hat - y)^2)} } else if (type == &quot;absolute_error&quot;) { loss &lt;- function(y_hat, y) {sum(abs(y_hat - y))} } else if (type == &quot;binary_cross_entropy&quot;) { loss &lt;- function(y_hat, y) {-(y * log(y_hat) + (1-y) * log(1 - y_hat))} } else if (type == &quot;categorical_cross_entropy&quot;) { loss &lt;- function(y_hat, y) {-sum(y * log(y_hat))} } else (return(NULL)) return(loss) } get_loss_prime &lt;- function(type = &quot;squared_error&quot;) { if (type == &quot;squared_error&quot;) { loss_prime &lt;- function(y_hat, y) {sum(2 * (y_hat - y))} } else if (type == &quot;absolute_error&quot;) { loss_prime &lt;- function(y_hat, y) {sum(sign(y_hat - y))} } else if (type == &quot;binary_cross_entropy&quot;) { loss_prime &lt;- function(y_hat, y) {-((y / y_hat) - ((1 - y) / (1 - y_hat)))} } else if (type == &quot;categorical_cross_entropy&quot;) { loss_prime &lt;- function(y_hat, y) {-sum(y / y_hat)} } else (return(NULL)) return(loss_prime) } 5.2.3 Misc Helpers ## creates a list of n empty lists create_lists &lt;- function(n) { out &lt;- list() for (i in 1:n) { out[[i]] &lt;- list() } return(out) } ## friendlier diag() function diag_D &lt;- function(x) { if (length(x) == 1) { out &lt;- x } else { out &lt;- diag(as.numeric(x)) } return(out) } generate_layer_sizes &lt;- function(X, Y, hidden_layer_sizes) { return(c(nrow(X), hidden_layer_sizes, nrow(Y))) } initialize_NN &lt;- function(layer_sizes, activation_function = &quot;sigmoid&quot;, last_activation_function = &quot;identity&quot;, lower_bound = 0, upper_bound = 1) { n &lt;- layer_sizes ## initialize parameter matrices W &lt;- list() b &lt;- list() ## could vectorize w/ mapply() for (l in 2:length(n)) { W[[l]] &lt;- matrix(data = runif(n = n[l - 1] * n[l], min = lower_bound, max = upper_bound), nrow = n[l], ncol = n[l - 1]) b[[l]] &lt;- matrix(data = runif(n = n[l], min = lower_bound, max = upper_bound), nrow = n[l], ncol = 1) } ## return return(list(W = W, b = b, activation_function = activation_function, last_activation_function = last_activation_function)) } 5.2.4 Forward Propagation NN_output &lt;- function(X, NN_obj) { L &lt;- length(NN_obj$W) ## if X is one obs, input will be a vector so dim will be null m &lt;- ifelse(is.null(ncol(X)), 1, ncol(X)) g &lt;- get_link(NN_obj$activation_function) g_last &lt;- get_link(NN_obj$last_activation_function) a &lt;- list() a[[1]] &lt;- X for (l in 2:(L - 1)) { a[[l]] &lt;- g(NN_obj$W[[l]] %*% a[[l - 1]] + matrix(data = rep(x = NN_obj$b[[l]], times = m), ncol = m)) } a[[L]] &lt;- g_last(NN_obj$W[[L]] %*% a[[L - 1]] + matrix(data = rep(x = NN_obj$b[[L]], times = m), ncol = m)) return(a[[L]]) } 5.2.5 Gradient Descent Iteration GD_iter &lt;- function(NN_obj, X, Y, rho = 1, verbose = FALSE, very_verbose = FALSE) { L &lt;- length(NN_obj$W) ## if X is one obs, input will be a vector so dim will be null m &lt;- ifelse(is.null(ncol(X)), 1, ncol(X)) ## get links g &lt;- get_link(NN_obj$activation_function) g_prime &lt;- get_link_prime(NN_obj$activation_function) g_last &lt;- get_link(NN_obj$last_activation_function) g_last_prime &lt;- get_link_prime(NN_obj$last_activation_function) z &lt;- create_lists(L) a &lt;- create_lists(L) D &lt;- create_lists(L) delta &lt;- create_lists(L) del_W &lt;- create_lists(L) del_b &lt;- create_lists(L) ## gradient descent for (i in 1:m) { ## forward a[[1]][[i]] &lt;- X[, i] for (l in 2:(L - 1)) { z[[l]][[i]] &lt;- NN_obj$W[[l]] %*% a[[l - 1]][[i]] + NN_obj$b[[l]] a[[l]][[i]] &lt;- g(z[[l]][[i]]) D[[l]][[i]] &lt;- diag_D(g_prime(z[[l]][[i]])) if (very_verbose == TRUE) {print(paste0(&quot;Forward: obs &quot;, i, &quot; - layer &quot;, l))} } ## last layer z[[L]][[i]] &lt;- NN_obj$W[[L]] %*% a[[L - 1]][[i]] + NN_obj$b[[L]] a[[L]][[i]] &lt;- g_last(z[[L]][[i]]) D[[L]][[i]] &lt;- diag_D(g_last_prime(z[[L]][[i]])) ## backward # eventually fix to match with loss function delta[[L]][[i]] &lt;- D[[L]][[i]] %*% (a[[L]][[i]] - Y[, i]) for (l in (L - 1):2) { delta[[l]][[i]] &lt;- D[[l]][[i]] %*% t(NN_obj$W[[l + 1]]) %*% delta[[l + 1]][[i]] if (very_verbose == TRUE) {print(paste0(&quot;Backward: obs &quot;, i, &quot; - layer &quot;, l))} } for (l in 2:L) { del_W[[l]][[i]] &lt;- delta[[l]][[i]] %*% t(a[[l - 1]][[i]]) del_b[[l]][[i]] &lt;- delta[[l]][[i]] if (very_verbose == TRUE) {print(paste0(&quot;del: obs &quot;, i, &quot; - layer &quot;, l))} } if ((verbose == TRUE) &amp; (i %% 100 == 0)) {print(paste(&quot;obs&quot;, i, &quot;/&quot;, m))} } ## update parameters # get averages ## del_W is a list where each element represents a layer ## in each layer, there&#39;s a list representing the layer&#39;s result for that obs ## here we collapse the results by taking the sum of our gradients del_W_all &lt;- lapply(X = del_W, FUN = Reduce, f = &quot;+&quot;) %&gt;% lapply(X = ., FUN = function(x) x / m) del_b_all &lt;- lapply(X = del_b, FUN = Reduce, f = &quot;+&quot;) %&gt;% lapply(X = ., FUN = function(x) x / m) # apply gradient W_out &lt;- mapply(FUN = function(A, del_A) {A - rho * del_A}, A = NN_obj$W, del_A = del_W_all) b_out &lt;- mapply(FUN = function(A, del_A) {A - rho * del_A}, A = NN_obj$b, del_A = del_b_all) ## return a new NN object return(list(W = W_out, b = b_out, activation_function = NN_obj$activation_function, last_activation_function = NN_obj$last_activation_function)) } 5.2.6 Perform Gradient Descent GD_perform &lt;- function(X, Y, init_NN_obj, rho = 0.01, loss_function = &quot;squared_error&quot;, threshold = 1, max_iter = 100, print_descent = FALSE) { ## setup done_decreasing &lt;- FALSE objective_function &lt;- get_loss_function(type = loss_function) iteration_outputs &lt;- list() output_objectives &lt;- numeric() iteration_input &lt;- init_NN_obj iter &lt;- 1 initial_objective &lt;- objective_function(y = Y, y_hat = NN_output(X = X, NN_obj = init_NN_obj)) if (print_descent == TRUE) { print(paste0(&quot;iter: &quot;, 0, &quot;; obj: &quot;, round(initial_objective, 1))) } while ((!done_decreasing) &amp; (iter &lt; max_iter)) { ## get input loss in_objective &lt;- objective_function(y = Y, y_hat = NN_output(X = X, NN_obj = iteration_input)) ## iterate iteration_output &lt;- GD_iter(NN_obj = iteration_input, X = X, Y = Y, rho = rho, verbose = FALSE, very_verbose = FALSE) ## outputs out_objective &lt;- objective_function(y = Y, y_hat = NN_output(X = X, NN_obj = iteration_output)) iteration_input &lt;- iteration_output iteration_outputs[[iter]] &lt;- iteration_output output_objectives[[iter]] &lt;- out_objective if (print_descent == TRUE) { print(paste0(&quot;iter: &quot;, iter, &quot;; obj: &quot;, round(out_objective, 1))) } iter &lt;- iter + 1 ## evaluate if (abs(in_objective - out_objective) &lt; threshold) { done_decreasing &lt;- TRUE } } return(list(final_NN = iteration_output, intermediate_NN = iteration_outputs, output_objectives = output_objectives, initial_objective = initial_objective, params = list(rho = rho, loss_function = loss_function, initial_NN = init_NN_obj))) } 5.2.7 Summary Functions GD_plot &lt;- function(GD_obj) { data.frame(x = 1:length(GD_obj$output_objectives), y = GD_obj$output_objectives) %&gt;% ggplot(aes(x = x, y = y)) + geom_point() + theme_bw() + labs(x = &quot;Iteration&quot;, y = &quot;Loss&quot;) } GD_summary &lt;- function(GD_obj, print_summary = TRUE) { ## num iter num_iter &lt;- length(GD_obj$output_objectives) ## loss improvement initial_objective &lt;- GD_obj$initial_objective %&gt;% round(1) final_objective &lt;- last(GD_obj$output_objectives) %&gt;% round(1) loss_improvement_ratio &lt;- (final_objective / initial_objective) %&gt;% round(4) if (print_summary == TRUE) { ## prints cat(paste0(&quot;Gradient Descent Summary:&quot;, &quot;\\n&quot;, &quot; |&quot;, &quot;\\n&quot;, &quot; | Number of Iterations: &quot;, num_iter, &quot;\\n&quot;, &quot; |&quot;, &quot;\\n&quot;, &quot; | Initial Objective: &quot;, initial_objective, &quot;\\n&quot;, &quot; | Final Objective: &quot;, final_objective, &quot;\\n&quot;, &quot; | Ratio: &quot;, loss_improvement_ratio, &quot;\\n&quot;, &quot;\\n&quot;)) cat(paste0(&quot;----------------------------------------&quot;, &quot;\\n&quot;, &quot;Initial W:&quot;, &quot;\\n&quot;, &quot;\\n&quot;)) print(GD_obj$params$initial_NN$W[-1]) cat(paste0(&quot;----------------------------------------&quot;, &quot;\\n&quot;, &quot;Final W:&quot;, &quot;\\n&quot;, &quot;\\n&quot;)) print(GD_obj$final_NN$W[-1]) cat(paste0(&quot;----------------------------------------&quot;, &quot;\\n&quot;, &quot;Initial b:&quot;, &quot;\\n&quot;, &quot;\\n&quot;)) print(GD_obj$params$initial_NN$b[-1]) cat(paste0(&quot;----------------------------------------&quot;, &quot;\\n&quot;, &quot;Final b:&quot;, &quot;\\n&quot;, &quot;\\n&quot;)) print(GD_obj$final_NN$b[-1]) } return(list(num_iter = num_iter, initial_objective = initial_objective, final_objective = final_objective, loss_improvement_ratio = loss_improvement_ratio)) } 5.3 Test ## initialize NN init_NN &lt;- initialize_NN(layer_sizes = generate_layer_sizes(X = X, Y = Y, hidden_layer_sizes = c(3)), activation_function = &quot;relu&quot;, last_activation_function = &quot;identity&quot;, lower_bound = 0, upper_bound = 1) ## train NN GD_NN &lt;- GD_perform(X = X, Y = Y, init_NN_obj = init_NN, rho = 0.001, loss_function = &quot;squared_error&quot;, threshold = 100, max_iter = 1000, print_descent = FALSE) final_NN &lt;- GD_NN$final_NN ## Summaries NN_sum &lt;- GD_summary(GD_obj = GD_NN) ## Gradient Descent Summary: ## | ## | Number of Iterations: 195 ## | ## | Initial Objective: 292351.5 ## | Final Objective: 17745.3 ## | Ratio: 0.0607 ## ## ---------------------------------------- ## Initial W: ## ## [[1]] ## [,1] [,2] [,3] ## [1,] 0.1405849 0.6126575 0.90775035 ## [2,] 0.2318597 0.7492433 0.37241190 ## [3,] 0.7124109 0.8722413 0.04381782 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] 0.1016381 0.4180429 0.02126928 ## ## ---------------------------------------- ## Final W: ## ## [[1]] ## X1 X2 X3 ## [1,] 0.06090143 0.008947117 2.4498792 ## [2,] 0.25129656 -0.084129255 1.7029701 ## [3,] 1.07769608 0.301962828 0.5952256 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] 2.262134 1.681697 0.7141668 ## ## ---------------------------------------- ## Initial b: ## ## [[1]] ## [,1] ## [1,] 0.3126643 ## [2,] 0.4585076 ## [3,] 0.4846150 ## ## [[2]] ## [,1] ## [1,] 0.6993605 ## ## ---------------------------------------- ## Final b: ## ## [[1]] ## [,1] ## [1,] 0.6466757 ## [2,] 0.8154999 ## [3,] 0.6364554 ## ## [[2]] ## [,1] ## [1,] 1.367471 GD_plot(GD_NN) 5.3.1 Other ## get_layer_size function get_layer_sizes &lt;- function(NN_obj) { n_1 &lt;- ncol(NN_obj$W[[2]]) n_H &lt;- sapply(NN_obj$W[-1], nrow) return(c(n_1, n_H)) } layer_sizes_test &lt;- get_layer_sizes(final_NN) 5.4 Cross Validation library(ggplot2) # Number of folds for cross-validation k &lt;- 5 max_iter &lt;- 100 # Set the maximum number of iterations for gradient descent # Initialize vectors to store training and validation losses train_losses &lt;- matrix(NA, nrow = max_iter, ncol = k) valid_losses &lt;- matrix(NA, nrow = max_iter, ncol = k) # Perform 5-fold cross-validation for (fold in 1:k) { ## Define fold indices for X and Y separately fold_indices_X &lt;- ((fold - 1) * ncol(X) / k + 1):(fold * ncol(X) / k) fold_indices_Y &lt;- ((fold - 1) * ncol(Y) / k + 1):(fold * ncol(Y) / k) ## Splitting the data into train and validation sets for X and Y X_valid_fold &lt;- X[, fold_indices_X] Y_valid_fold &lt;- Y[, fold_indices_Y, drop = FALSE] X_train_fold &lt;- X[, -fold_indices_X] Y_train_fold &lt;- Y[, -fold_indices_Y, drop = FALSE] # Perform gradient descent on the training set for this fold GD_NN &lt;- GD_perform(X = X_train_fold, Y = Y_train_fold, init_NN_obj = init_NN, rho = 0.001, loss_function = &quot;squared_error&quot;, threshold = 100, max_iter = 1000, print_descent = FALSE) # Evaluate the model on the validation set for this fold objective_function &lt;- function(y, y_hat) { return(get_loss_function(type = &quot;squared_error&quot;)(y_hat, y)) } for (epoch in 1:max_iter) { train_loss &lt;- objective_function(y = Y_train_fold, y_hat = NN_output(X = X_train_fold, NN_obj = GD_NN$intermediate_NN[[epoch]])) valid_loss &lt;- objective_function(y = Y_valid_fold, y_hat = NN_output(X = X_valid_fold, NN_obj = GD_NN$intermediate_NN[[epoch]])) train_losses[epoch, fold] &lt;- train_loss valid_losses[epoch, fold] &lt;- valid_loss } } # Plot training and validation losses epoch &lt;- 1:max_iter train_loss_mean &lt;- apply(train_losses, 1, mean) valid_loss_mean &lt;- apply(valid_losses, 1, mean) df_loss &lt;- data.frame(epoch = epoch, train_loss = train_loss_mean, valid_loss = valid_loss_mean) ggplot(data = df_loss, aes(x = epoch)) + geom_line(aes(y = train_loss, color = &quot;Train Loss&quot;)) + geom_line(aes(y = valid_loss, color = &quot;Validation Loss&quot;)) + scale_color_manual(values = c(&quot;Train Loss&quot; = &quot;blue&quot;, &quot;Validation Loss&quot; = &quot;red&quot;)) + labs(x = &quot;Epoch&quot;, y = &quot;Loss&quot;, color = &quot;Loss Type&quot;) + ggtitle(&quot;Training and Validation Losses&quot;) + theme_minimal() 5.5 Next Steps In the future: need some sort of divergence check / pick ‘best so far’ output vis for gradient descent — pick 2 vars and for every combo of those 2, plot the objective function vis for gradient descent — show the evolution of the var through gradient descent over iterations NN overall vis &amp; perhaps animation multi-dimensional output (cat / 1-hot) different cost functions (softmax squared-error &amp; cross-entropy) ‘from scratch’ from scratch — mmult and maybe further lol get ‘best-case’ / perfect objective function (if data creation process known) stochastic gradient descent, minibatches (what gets passed down to GD_iter from GD_perform) regularization methods &amp; CV-validation "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
